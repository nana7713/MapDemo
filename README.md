应用最底层的是MapApp.java 

MapApp类继承了Application 在OnCreate方法中初始化了数据库 并且提供了getAppDb的方法来调用数据库

同时在此层还定义了UserID 即在登录后应用为该UserID所有者服务 提供getUserID和setUserID（登录时调用）的方法
接着是MainActivity.java

dispatchTouchEvent方法用于取消导航列表，当触摸结果在导航列表之外，隐藏结果列表

导航栏设置点击监听 通过FragmentManager启动FragmentTransaction的replace方法切换界面

布局上来看就是底端的导航栏和剩余部分的fragment（@+id/fragment），后续的切换fragment都是在替换MainActivity布局中id为fragment的部分

*fragment内部的初始化一般在onViewCreated方法内完成

导航栏的首页，由MapFragment.java负责实现，显示地图，定位以及导航都别迁移到这个fragment进行完成。
CoordinateUtils,OverlayManager,PoiAdapter,PoiOverlay都是为了实现地图功能创建的辅助类。

导航栏的发现，由FindFragment.java负责实现，尚未完善。

导航栏的我的，初次点击切换至LoginFragment，实现登录功能，登录成功跳转至MyPageFragment，没有账号可以点击register文本按钮跳转至RegisterFragment。通过sharedPreferences实现了保存密码和自动登录功能，勾选自动登录后在下次点击导航栏的我的时，会直接跳转至MyPageFragment，实际上还是一个切换为LoginFragment的过程，只不过在LoginFragment的初始化过程中添加了条件判断，如果sharedPreferences存储的自动登录状态为true，直接再进行一次切换至MyPageFragment。

Database包中定义了AppDatabase类，以及User和NoteEntity两种实体（表），User的每个实例都代表应用数据库中user表中的一行（NoteEntity同理）。NoteEntity和User通过@ForeignKey注解绑定在一起（User的uid映射到NoteEntity的userId），NoteDao和UserDao接口负责对应实例的方法实现。

RegisterFragment中在注册完成后会将注册信息通过userDao的InsetAll方法插入数据库中。

MyPageFragment使用了ListView，分别有我的笔记，我的相册，设置三个item。

点击我的笔记进入FragmentNote，我的相册未完善，点击设置进入SetFragment。在SerFragment中完成个人信息的设置，退出登录按钮可以接触自动登录状态。

FragmentNote使用了RecyclerView（一种循环列表）需要创建一个辅助类，即MyAdapter来帮助填充列表内的每一个item。

Bean包内定义了一个NoteCard类，填充时用的是List<NoteCard>，因此需要使用noteToCard方法进行转换（这部分我是顺着b站一个视频的思路写的，关于为什么要再定义一个类而不是直接用List<List<NoteEntity>我还没搞明白）

MyAdapter是继承了RecyclerView.Adapter的一个类，我们要做的就是根据需求重写几个关键方法，其他的事这个父类都会做好。
MyAdapter里面的MyViewHolder就是来存放列表的每个item的，onCreateViewHolder要做的就是把你想要的item布局填充进去，onBindViewHolder就是来给item里的控件赋你想要的值，这个方法的position参数就是item的序号。

至于MyAdapter末尾的两个接口，是用来进行MyAdapetr之外的操作的。将接口定义为MyAdapter类的属性，在外部实例化MyAdapter时通过构造函数传入实现这些接口的匿名内部类，这样就可以将无法在MyAdapter内实现的操作写在匿名内部类的方法中，并且在MyAdapter里面进行调用，例如Helper和Count（有点绕）

FragmentNote中点击floatButton进入AddNoteFragment，进行笔记编辑。

你可以直接点击itemCard进行编辑（有笔记的前提下），监听器位于MyAdapter内，*FragmentActivity 及其子类（如 AppCompatActivity）都可以通过 getSupportFragmentManager() 方法访问 FragmentManager。但由于MyAdapter不属于上述情况，因此无法调用FragmentManager，所以这里用上了前面提到的Helper方法。点击后替换为AddNoteFragment，并且setArugment的方法进行了fragment间的信息传递，将is_new状态设置为false。

Glide方法渲染图片虽然简洁，但是会出现图片不更新的bug（可能是我还没掌握清楚），所以很多地方的Glide都改成了Bitmap的渲染方式。






